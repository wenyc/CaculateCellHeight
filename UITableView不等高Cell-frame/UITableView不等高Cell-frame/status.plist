<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array>
	<dict>
		<key>text</key>
		<string>An instance of UITableView (or simply, a table view) is a means for displaying and editing hierarchical lists of information.</string>
		<key>icon</key>
		<string>204.png</string>
		<key>name</key>
		<string>Michelle</string>
	</dict>
	<dict>
		<key>text</key>
		<string>A table view displays a list of items in a single column. UITableView is a subclass of UIScrollView, which allows users to scroll through the table, although UITableView allows vertical scrolling only. The cells comprising the individual items of the table are UITableViewCell objects; UITableView uses these objects to draw the visible rows of the table. Cells have content—titles and images—and can have, near the right edge, accessory views. Standard accessory views are disclosure indicators or detail disclosure buttons; the former leads to the next level in a data hierarchy and the latter leads to a detailed view of a selected item. Accessory views can also be framework controls, such as switches and sliders, or can be custom views. Table views can enter an editing mode where users can insert, delete, and reorder rows of the table.</string>
		<key>icon</key>
		<string>3829.png</string>
		<key>name</key>
		<string>Gabrielle</string>
	</dict>
	<dict>
		<key>text</key>
		<string>A table view is made up of zero or more sections, each with its own rows. Sections are identified by their index number within the table view, and rows are identified by their index number within a section. Any section can optionally be preceded by a section header, and optionally be followed by a section footer.</string>
		<key>icon</key>
		<string>13186.png</string>
		<key>name</key>
		<string>Rafael</string>
	</dict>
	<dict>
		<key>text</key>
		<string>Table views can have one of two styles, UITableViewStylePlain and UITableViewStyleGrouped. When you create a UITableView instance you must specify a table style, and this style cannot be changed. In the plain style, section headers and footers float above the content if the part of a complete section is visible. A table view can have an index that appears as a bar on the right hand side of the table (for example, &quot;A&quot; through &quot;Z&quot;). You can touch a particular label to jump to the target section. The grouped style of table view provides a default background color and a default background view for all cells. The background view provides a visual grouping for all cells in a particular section. For example, one group could be a person&apos;s name and title, another group for phone numbers that the person uses, and another group for email accounts and so on. See the Settings application for examples of grouped tables. Table views in the grouped style cannot have an index.</string>
		<key>icon</key>
		<string>536855.png</string>
		<key>name</key>
		<string>Cassiel</string>
	</dict>
	<dict>
		<key>text</key>
		<string>Many methods of UITableView take NSIndexPath objects as parameters and return values. UITableView declares a category on NSIndexPath that enables you to get the represented row index (row property) and section index (section property), and to construct an index path from a given row index and section index (indexPathForRow:inSection: method). Especially in table views with multiple sections, you must evaluate the section index before identifying a row by its index number.</string>
		<key>icon</key>
		<string>536858.png</string>
		<key>name</key>
		<string>Amaris</string>
	</dict>
	<dict>
		<key>text</key>
		<string>A UITableView object must have an object that acts as a data source and an object that acts as a delegate; typically these objects are either the application delegate or, more frequently, a custom UITableViewController object. The data source must adopt the UITableViewDataSource protocol and the delegate must adopt the UITableViewDelegate protocol. The data source provides information that UITableView needs to construct tables and manages the data model when rows of a table are inserted, deleted, or reordered. The delegate manages table row configuration and selection, row reordering, highlighting, accessory views, and editing operations.</string>
		<key>icon</key>
		<string>536863.png</string>
		<key>name</key>
		<string>Dabria</string>
	</dict>
	<dict>
		<key>text</key>
		<string>When sent a setEditing:animated: message (with a first parameter of YES), the table view enters into editing mode where it shows the editing or reordering controls of each visible row, depending on the editingStyle of each associated UITableViewCell. Clicking on the insertion or deletion control causes the data source to receive a tableView:commitEditingStyle:forRowAtIndexPath: message. You commit a deletion or insertion by calling deleteRowsAtIndexPaths:withRowAnimation: or insertRowsAtIndexPaths:withRowAnimation:, as appropriate. Also in editing mode, if a table-view cell has its showsReorderControl property set to YES, the data source receives tableView:moveRowAtIndexPath:toIndexPath: message. The data source can selectively remove the reordering control for cells by implementing tableView:canMoveRowAtIndexPath</string>
		<key>icon</key>
		<string>1167475.png</string>
		<key>name</key>
		<string>Katherine</string>
	</dict>
	<dict>
		<key>text</key>
		<string>UITableView caches table-view cells for visible rows. You can create custom UITableViewCell objects with content or behavioral characteristics that are different than the default cells; A Closer Look at Table View Cells explains how.</string>
		<key>icon</key>
		<string>1167484.png</string>
		<key>name</key>
		<string>Gabrielle</string>
	</dict>
	<dict>
		<key>text</key>
		<string>UITableView overrides the layoutSubviews method of UIView so that it calls reloadData only when you create a new instance of UITableView or when you assign a new data source. Reloading the table view clears current state, including the current selection. However, if you explicitly call reloadData, it clears this state and any subsequent direct or indirect call to layoutSubviews does not trigger a reload.</string>
		<key>icon</key>
		<string>1167486.png</string>
		<key>name</key>
		<string>Scandinavian</string>
	</dict>
	<dict>
		<key>text</key>
		<string>For information about basic view behaviors, see View Programming Guide for iOS.</string>
		<key>icon</key>
		<string>1167504.png</string>
		<key>name</key>
		<string>Lirica</string>
	</dict>
</array>
</plist>
